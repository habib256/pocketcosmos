<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entra√Ænement IA - Rocket Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
            color: white;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-weight: bold;
            color: #8cf;
        }
        input, select, button {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #333;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        button {
            background: linear-gradient(45deg, #4a90e2, #7b68ee);
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background: linear-gradient(45deg, #5ba0f2, #8b78fe);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        .metric, .metric-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #8cf;
        }
        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2, #7b68ee);
            width: 0%;
            transition: width 0.3s ease;
        }
        .log-container {
            height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
        }
        .log-entry {
            margin: 2px 0;
            opacity: 0.8;
        }
        .log-error { color: #ff6b6b; }
        .log-success { color: #51cf66; }
        .log-info { color: #74c0fc; }
        .charts {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        .chart-container {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            height: 200px;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-idle { background: #ffd43b; }
        .status-training { background: #51cf66; animation: pulse 1s infinite; }
        .status-error { background: #ff6b6b; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .visualization-panel {
            grid-column: 1 / -1; /* Prendre toute la largeur */
            height: 650px;
            position: relative;
        }
        .visualization-canvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
            background: #000;
            display: block;
            box-sizing: border-box;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .visualization-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        .visualization-controls button {
            padding: 6px 12px;
            font-size: 12px;
            white-space: nowrap;
            min-width: 80px;
        }
    </style>
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.13.0/dist/tf.min.js"></script>
    <!-- Chart.js pour les graphiques -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Biblioth√®ques physiques -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- Plugin Matter Attractors -->
    <script src="https://cdn.jsdelivr.net/npm/matter-attractors@0.1.6/build/matter-attractors.min.js"></script>
    
    <!-- D√©pendances n√©cessaires pour l'entra√Ænement -->
    <script src="constants.js"></script>
    <script src="controllers/EventBus.js"></script>
    <script src="EventTypes.js"></script>
    <script src="models/UniverseModel.js"></script>
    <script src="models/CelestialBodyModel.js"></script>
    <script src="models/RocketModel.js"></script>
    <script src="models/CameraModel.js"></script>
    <script src="models/ParticleModel.js"></script>
    <script src="models/ParticleSystemModel.js"></script>
    
    <!-- Contr√¥leurs n√©cessaires pour HeadlessRocketEnvironment -->
    <script src="controllers/BodyFactory.js"></script>
    <script src="controllers/CollisionHandler.js"></script>
    <script src="controllers/ThrusterPhysics.js"></script>
    <script src="controllers/SynchronizationManager.js"></script>
    <script src="controllers/PhysicsVectors.js"></script>
    <script src="controllers/PhysicsController.js"></script>
    <script src="controllers/ParticleController.js"></script>
    <script src="controllers/RocketController.js"></script>
    <script src="controllers/MissionManager.js"></script>
    <script src="controllers/RocketCargo.js"></script>
    <script src="controllers/CelestialBodyFactory.js"></script>
    <script src="controllers/ControllerContainer.js"></script>
    
    <!-- Composants IA -->
    <script src="controllers/RocketAI.js"></script>
    <script src="controllers/HeadlessRocketEnvironment.js"></script>
    <script src="controllers/TrainingOrchestrator.js"></script>
    <script src="controllers/TrainingVisualizer.js"></script>
    
    <!-- Scripts de test et d√©monstration -->
    <script src="train.js"></script>
</head>
<body>
    <div class="container">
        <div class="panel">
            <h2>üöÄ Configuration d'Entra√Ænement</h2>
            <div class="controls">
                <div class="control-group">
                    <label>√âpisodes d'entra√Ænement:</label>
                    <input type="number" id="episodes" value="1000" min="10" max="10000">
                </div>
                <div class="control-group">
                    <label>Taux d'apprentissage:</label>
                    <input type="number" id="learningRate" value="0.001" step="0.0001" min="0.0001" max="0.1">
                </div>
                <div class="control-group">
                    <label>Epsilon initial:</label>
                    <input type="number" id="epsilon" value="1.0" step="0.1" min="0.1" max="1.0">
                </div>
                <div class="control-group">
                    <label>Gamma (discount factor):</label>
                    <input type="number" id="gamma" value="0.99" step="0.01" min="0.8" max="0.99">
                </div>
                <div class="control-group">
                    <label>Taille du batch:</label>
                    <input type="number" id="batchSize" value="32" min="8" max="128">
                </div>
                <div class="control-group">
                    <label>Fr√©quence de mise √† jour:</label>
                    <input type="number" id="updateFreq" value="4" min="1" max="100">
                </div>
                <div class="control-group">
                    <label>Objectif d'entra√Ænement:</label>
                    <select id="objective">
                        <option value="orbit">Maintenir orbite</option>
                        <option value="land">Atterrissage pr√©cis</option>
                        <option value="explore">Exploration libre</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Mode d'entra√Ænement:</label>
                    <select id="trainingMode">
                        <option value="headless">Sans rendu (rapide)</option>
                        <option value="visual">Avec visualisation</option>
                    </select>
                </div>
            </div>
            
            <div class="controls">
                <button id="startTraining">üéØ D√©marrer l'Entra√Ænement</button>
                <button id="pauseTraining" disabled>‚è∏Ô∏è Pause</button>
                <button id="stopTraining" disabled>‚èπÔ∏è Arr√™ter</button>
                <button id="saveModel">üíæ Sauvegarder Mod√®le</button>
                <button id="loadModel">üìÇ Charger Mod√®le</button>
                <button id="resetTraining">üîÑ Reset</button>
            </div>
        </div>

        <div class="panel">
            <h2>üìä M√©triques en Temps R√©el</h2>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="currentEpisode">0</div>
                    <div class="metric-label">√âpisode Actuel</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="totalSteps">0</div>
                    <div class="metric-label">√âtapes Totales</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="averageReward">0.00</div>
                    <div class="metric-label">R√©compense Moy.</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="successRate">0.0%</div>
                    <div class="metric-label">Taux de Succ√®s</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="explorationRate">1.000</div>
                    <div class="metric-label">Exploration (Œµ)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="trainingLoss">0.0000</div>
                    <div class="metric-label">Perte d'Entra√Ænement</div>
                </div>
            </div>
            
            <div>
                <h3>Progression:</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="trainingProgress"></div>
                </div>
                <div id="progressText">Pr√™t pour l'entra√Ænement</div>
            </div>
        </div>

        <!-- Panneau de visualisation -->
        <div class="panel visualization-panel" id="visualizationPanel" style="display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h2 style="margin: 0;">üéØ Visualisation de l'Entra√Ænement</h2>
                <div class="visualization-controls">
                    <button id="toggleVisualization">üëÅÔ∏è Activer</button>
                    <button id="clearTrajectory">üßπ Effacer</button>
                    <button id="zoomOut">üîç- Zoom</button>
                    <button id="zoomIn">üîç+ Zoom</button>
                </div>
            </div>
            <div style="display: flex; justify-content: center; align-items: center; height: calc(100% - 50px);">
                <canvas id="visualizationCanvas" class="visualization-canvas"></canvas>
            </div>
        </div>

        <div class="panel">
            <h2>üìà Graphiques de Performance</h2>
            <div class="charts">
                <div class="chart-container">
                    <canvas id="rewardChart"></canvas>
                </div>
                <div class="chart-container">
                    <canvas id="lossChart"></canvas>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>üìä M√©triques de Concurrence TensorFlow.js</h2>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="totalTrainingCalls">0</div>
                    <div class="metric-label">Appels Totaux</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="blockedCalls">0</div>
                    <div class="metric-label">Appels Bloqu√©s</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="successfulTrainings">0</div>
                    <div class="metric-label">Entra√Ænements R√©ussis</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="blockingRate">0.0%</div>
                    <div class="metric-label">Taux de Blocage</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="averageTrainingDuration">0</div>
                    <div class="metric-label">Dur√©e Moy. (ms)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="lastTrainingTime">0</div>
                    <div class="metric-label">Derni√®re Dur√©e (ms)</div>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>üìù Journal d'Entra√Ænement</h2>
            <div>
                <span class="status-indicator" id="statusIndicator"></span>
                <span id="statusText">Inactif</span>
            </div>
            <div class="log-container" id="logContainer">
                <div class="log-entry log-info">Interface d'entra√Ænement initialis√©e.</div>
                <div class="log-entry log-info">TensorFlow.js charg√© avec succ√®s.</div>
                <div class="log-entry log-info">Pr√™t pour l'entra√Ænement...</div>
            </div>
        </div>

        <div class="panel">
            <h2>üìà Statistiques d'Entra√Ænement</h2>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="totalTrainingTime">0s</div>
                    <div class="metric-label">Temps Total</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="averageEpisodeTime">0s</div>
                    <div class="metric-label">Temps Moy./√âpisode</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="bestReward">0.00</div>
                    <div class="metric-label">Meilleure R√©compense</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="modelSize">0 KB</div>
                    <div class="metric-label">Taille du Mod√®le</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="memoryUsage">0 MB</div>
                    <div class="metric-label">M√©moire Utilis√©e</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="trainingEfficiency">0%</div>
                    <div class="metric-label">Efficacit√©</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Initialisation du plugin Matter Attractors -->
    <script>
        // Gestionnaire d'erreurs global pour capturer les probl√®mes
        window.addEventListener('error', (event) => {
            console.error('Erreur JS d√©tect√©e:', event.error);
            const errorMsg = `ERREUR: ${event.error?.message || event.message}\nFichier: ${event.filename}\nLigne: ${event.lineno}`;
            if (window.trainingInterface) {
                window.trainingInterface.log(errorMsg, 'error');
            }
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Promesse rejet√©e:', event.reason);
            if (window.trainingInterface) {
                window.trainingInterface.log(`Promesse rejet√©e: ${event.reason}`, 'error');
            }
        });

        try {
            Matter.use(MatterAttractors);
            console.log('Plugin Matter Attractors initialis√© avec succ√®s');
        } catch (e) {
            console.error("Erreur lors de l'initialisation du plugin Matter Attractors:", e);
        }
    </script>

    <script>
        // Configuration globale de l'interface d'entra√Ænement
        class TrainingInterface {
            constructor() {
                this.isTraining = false;
                this.isPaused = false;
                this.currentEpisode = 0;
                this.totalSteps = 0;
                this.trainingData = {
                    rewards: [],
                    losses: [],
                    episodes: []
                };
                
                this.log('Initialisation de l\'interface d\'entra√Ænement...', 'info');
                
                try {
                    // V√©rifier les d√©pendances critiques
                    this.checkDependencies();
                    
                    // Initialiser les composants r√©els d'entra√Ænement
                    this.eventBus = new EventBus();
                    this.trainingOrchestrator = new TrainingOrchestrator(this.eventBus);
                    
                    // Initialiser le visualiseur
                    this.initializeVisualizer();
                    
                    this.initializeCharts();
                    this.setupEventListeners();
                    this.setupTrainingEventListeners();
                    this.updateStatus('idle', 'Pr√™t pour l\'entra√Ænement');
                    
                    this.log('Interface d\'entra√Ænement initialis√©e avec succ√®s', 'success');
                } catch (error) {
                    this.log(`Erreur lors de l'initialisation: ${error.message}`, 'error');
                    this.updateStatus('error', 'Erreur d\'initialisation');
                }
            }

            checkDependencies() {
                const dependencies = [
                    { name: 'TensorFlow.js', check: () => typeof tf !== 'undefined' },
                    { name: 'Matter.js', check: () => typeof Matter !== 'undefined' },
                    { name: 'Matter Attractors', check: () => typeof MatterAttractors !== 'undefined' },
                    { name: 'EVENTS', check: () => typeof window.EVENTS !== 'undefined' },
                    { name: 'ROCKET constants', check: () => typeof ROCKET !== 'undefined' && typeof ROCKET.FUEL_MAX !== 'undefined' },
                    { name: 'PHYSICS constants', check: () => typeof PHYSICS !== 'undefined' },
                    { name: 'EventBus', check: () => typeof EventBus !== 'undefined' },
                    { name: 'TrainingOrchestrator', check: () => typeof TrainingOrchestrator !== 'undefined' },
                    { name: 'HeadlessRocketEnvironment', check: () => typeof HeadlessRocketEnvironment !== 'undefined' },
                    { name: 'RocketAI', check: () => typeof RocketAI !== 'undefined' },
                    { name: 'TrainingVisualizer', check: () => typeof TrainingVisualizer !== 'undefined' }
                ];

                const missing = dependencies.filter(dep => !dep.check());
                if (missing.length > 0) {
                    const missingNames = missing.map(dep => dep.name).join(', ');
                    throw new Error(`D√©pendances manquantes: ${missingNames}`);
                }
                
                this.log('Toutes les d√©pendances sont pr√©sentes', 'success');
            }

            initializeCharts() {
                // Graphique des r√©compenses
                const rewardCtx = document.getElementById('rewardChart').getContext('2d');
                this.rewardChart = new Chart(rewardCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'R√©compense Moyenne',
                            data: [],
                            borderColor: '#4a90e2',
                            backgroundColor: 'rgba(74, 144, 226, 0.1)',
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { 
                                display: true,
                                labels: { color: 'white' }
                            },
                            title: {
                                display: true,
                                text: '√âvolution des R√©compenses',
                                color: 'white',
                                font: { size: 14 }
                            }
                        },
                        scales: {
                            x: { 
                                display: true,
                                title: {
                                    display: true,
                                    text: '√âpisodes d\'Entra√Ænement',
                                    color: 'white',
                                    font: { size: 12 }
                                },
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: { color: 'white' }
                            },
                            y: { 
                                title: {
                                    display: true,
                                    text: 'R√©compense Moyenne',
                                    color: 'white',
                                    font: { size: 12 }
                                },
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: { color: 'white' }
                            }
                        }
                    }
                });

                // Graphique des pertes
                const lossCtx = document.getElementById('lossChart').getContext('2d');
                this.lossChart = new Chart(lossCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Perte d\'Entra√Ænement',
                            data: [],
                            borderColor: '#7b68ee',
                            backgroundColor: 'rgba(123, 104, 238, 0.1)',
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { 
                                display: true,
                                labels: { color: 'white' }
                            },
                            title: {
                                display: true,
                                text: '√âvolution de la Perte d\'Entra√Ænement',
                                color: 'white',
                                font: { size: 14 }
                            }
                        },
                        scales: {
                            x: { 
                                display: true,
                                title: {
                                    display: true,
                                    text: '√âpisodes d\'Entra√Ænement',
                                    color: 'white',
                                    font: { size: 12 }
                                },
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: { color: 'white' }
                            },
                            y: { 
                                title: {
                                    display: true,
                                    text: 'Valeur de la Perte (Loss)',
                                    color: 'white',
                                    font: { size: 12 }
                                },
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: { color: 'white' }
                            }
                        }
                    }
                });
            }

            setupEventListeners() {
                document.getElementById('startTraining').addEventListener('click', () => this.startTraining());
                document.getElementById('pauseTraining').addEventListener('click', () => this.pauseTraining());
                document.getElementById('stopTraining').addEventListener('click', () => this.stopTraining());
                document.getElementById('saveModel').addEventListener('click', () => this.saveModel());
                document.getElementById('loadModel').addEventListener('click', () => this.loadModel());
                document.getElementById('resetTraining').addEventListener('click', () => this.resetTraining());
                
                // √âv√©nements de visualisation
                document.getElementById('toggleVisualization').addEventListener('click', () => this.toggleVisualization());
                document.getElementById('clearTrajectory').addEventListener('click', () => this.clearTrajectory());
                document.getElementById('zoomIn').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoomOut').addEventListener('click', () => this.zoomOut());
                
                // G√©rer le changement de mode d'entra√Ænement
                document.getElementById('trainingMode').addEventListener('change', (e) => this.onTrainingModeChanged(e.target.value));
            }

            setupTrainingEventListeners() {
                // √âcouter les √©v√©nements d'entra√Ænement r√©els
                this.eventBus.subscribe(window.EVENTS.AI.TRAINING_STARTED, (data) => {
                    this.log('Entra√Ænement d√©marr√©!', 'success');
                    this.updateStatus('training', 'Entra√Ænement en cours...');
                    this.isTraining = true;
                    this.updateButtons();
                });
                
                this.eventBus.subscribe(window.EVENTS.AI.TRAINING_PROGRESS, (data) => {
                    if (!data || !data.metrics) return;
                    
                    const metrics = data.metrics;
                    
                    // Calculer les m√©triques pour l'affichage avec des valeurs par d√©faut s√ªres
                    const avgReward = (metrics.averageRewards && metrics.averageRewards.length > 0) ? 
                        metrics.averageRewards.reduce((a, b) => a + b, 0) / metrics.averageRewards.length : 0;
                    const successRate = (metrics.successfulEpisodes && metrics.episode > 0) ? 
                        (metrics.successfulEpisodes / metrics.episode) * 100 : 0;
                    const currentEpsilon = (metrics.explorationRates && metrics.explorationRates.length > 0) ? 
                        metrics.explorationRates[metrics.explorationRates.length - 1] : 1.0;
                    const currentLoss = (metrics.losses && metrics.losses.length > 0) ? 
                        metrics.losses[metrics.losses.length - 1] : 0;
                    
                    this.updateMetrics({
                        episode: metrics.episode || 0,
                        totalSteps: metrics.totalSteps || 0,
                        avgReward: avgReward,
                        successRate: successRate,
                        epsilon: currentEpsilon,
                        loss: currentLoss
                    });
                    
                    // Mettre √† jour les graphiques p√©riodiquement
                    if (metrics.episode && metrics.episode % 10 === 0) {
                        this.updateCharts(metrics.episode, avgReward, currentLoss);
                    }
                    
                    // Log p√©riodique
                    if (metrics.episode && metrics.episode % 50 === 0) {
                        this.log(`√âpisode ${metrics.episode}: R√©compense=${avgReward.toFixed(2)}, Succ√®s=${successRate.toFixed(1)}%`, 'info');
                    }
                });
                
                this.eventBus.subscribe(window.EVENTS.AI.EVALUATION_COMPLETED, (data) => {
                    if (data && data.averageScore !== undefined && data.successRate !== undefined) {
                        this.log(`√âvaluation: Score=${data.averageScore.toFixed(2)}, Succ√®s=${(data.successRate * 100).toFixed(1)}%`, 'success');
                    }
                });
                
                this.eventBus.subscribe(window.EVENTS.AI.TRAINING_COMPLETED, (stats) => {
                    this.isTraining = false;
                    this.updateStatus('idle', 'Entra√Ænement termin√©');
                    this.updateButtons();
                    if (stats) {
                        this.log(`Entra√Ænement termin√©! √âpisodes: ${stats.episodes || 'N/A'}, Succ√®s: ${((stats.finalSuccessRate || 0) * 100).toFixed(1)}%`, 'success');
                    } else {
                        this.log('Entra√Ænement termin√©!', 'success');
                    }
                });
                
                this.eventBus.subscribe(window.EVENTS.AI.TRAINING_ERROR, (data) => {
                    this.isTraining = false;
                    this.updateStatus('error', 'Erreur d\'entra√Ænement');
                    this.updateButtons();
                    this.log(`Erreur: ${data?.error || 'Erreur inconnue'}`, 'error');
                });
                
                this.eventBus.subscribe(window.EVENTS.AI.TRAINING_STOPPED, () => {
                    this.isTraining = false;
                    this.isPaused = false;
                    this.updateStatus('idle', 'Entra√Ænement arr√™t√©');
                    this.updateButtons();
                    this.log('Entra√Ænement arr√™t√©', 'info');
                });

                this.eventBus.subscribe(window.EVENTS.AI.TRAINING_PAUSED, () => {
                    this.isPaused = true;
                    this.updateStatus('idle', 'Entra√Ænement en pause');
                    this.updateButtons();
                    this.log('Entra√Ænement mis en pause', 'info');
                });

                this.eventBus.subscribe(window.EVENTS.AI.TRAINING_RESUMED, () => {
                    this.isPaused = false;
                    this.updateStatus('training', 'Entra√Ænement repris');
                    this.updateButtons();
                    this.log('Entra√Ænement repris', 'info');
                });
            }

            startTraining() {
                if (this.isTraining && !this.isPaused) {
                    this.log('Entra√Ænement d√©j√† en cours', 'warning');
                    return;
                }

                if (this.isPaused) {
                    this.trainingOrchestrator.resumeTraining();
                    return;
                }

                try {
                    const config = this.getTrainingConfig();
                    this.log('D√©marrage de l\'entra√Ænement avec les param√®tres:', 'info');
                    this.log(JSON.stringify(config, null, 2), 'info');
                    
                    // Adapter la configuration pour TrainingOrchestrator
                    const orchestratorConfig = {
                        maxEpisodes: config.episodes,
                        learningRate: config.learningRate,
                        epsilon: config.epsilon,
                        gamma: config.gamma,
                        batchSize: config.batchSize,
                        headlessMode: config.trainingMode === 'headless',
                        objectives: [config.objective]
                    };
                    
                    // D√©marrer l'entra√Ænement r√©el
                    this.trainingOrchestrator.startTraining(orchestratorConfig)
                        .catch(error => {
                            this.log(`Erreur lors du d√©marrage: ${error.message}`, 'error');
                            this.isTraining = false;
                            this.updateButtons();
                            this.updateStatus('error', 'Erreur de d√©marrage');
                        });
                        
                } catch (error) {
                    this.log(`Erreur de configuration: ${error.message}`, 'error');
                    this.updateStatus('error', 'Erreur de configuration');
                }
            }

            pauseTraining() {
                if (!this.isTraining) return;
                this.trainingOrchestrator.pauseTraining();
            }

            resumeTraining() {
                if (!this.isPaused) return;
                this.trainingOrchestrator.resumeTraining();
            }

            stopTraining() {
                if (!this.isTraining) return;
                this.trainingOrchestrator.stopTraining();
            }

            getTrainingConfig() {
                return {
                    episodes: parseInt(document.getElementById('episodes').value) || 1000,
                    learningRate: parseFloat(document.getElementById('learningRate').value) || 0.001,
                    epsilon: parseFloat(document.getElementById('epsilon').value) || 1.0,
                    gamma: parseFloat(document.getElementById('gamma').value) || 0.99,
                    batchSize: parseInt(document.getElementById('batchSize').value) || 32,
                    updateFreq: parseInt(document.getElementById('updateFreq').value) || 4,
                    objective: document.getElementById('objective').value || 'orbit',
                    trainingMode: document.getElementById('trainingMode').value || 'headless'
                };
            }

            updateButtons() {
                const startBtn = document.getElementById('startTraining');
                const pauseBtn = document.getElementById('pauseTraining');
                const stopBtn = document.getElementById('stopTraining');
                
                if (this.isPaused) {
                    startBtn.textContent = '‚ñ∂Ô∏è Reprendre';
                    startBtn.disabled = false;
                    pauseBtn.disabled = true;
                    stopBtn.disabled = false;
                } else if (this.isTraining) {
                    startBtn.textContent = 'üéØ D√©marrer l\'Entra√Ænement';
                    startBtn.disabled = true;
                    pauseBtn.disabled = false;
                    stopBtn.disabled = false;
                } else {
                    startBtn.textContent = 'üéØ D√©marrer l\'Entra√Ænement';
                    startBtn.disabled = false;
                    pauseBtn.disabled = true;
                    stopBtn.disabled = true;
                }
            }

            updateStatus(status, text) {
                const indicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('statusText');
                
                indicator.className = `status-indicator status-${status}`;
                statusText.textContent = text;
            }

            updateMetrics(metrics) {
                document.getElementById('currentEpisode').textContent = metrics.episode || 0;
                document.getElementById('totalSteps').textContent = metrics.totalSteps || 0;
                document.getElementById('averageReward').textContent = (metrics.avgReward || 0).toFixed(2);
                document.getElementById('successRate').textContent = `${(metrics.successRate || 0).toFixed(1)}%`;
                document.getElementById('explorationRate').textContent = (metrics.epsilon || 0).toFixed(3);
                document.getElementById('trainingLoss').textContent = (metrics.loss || 0).toFixed(4);
                
                // Mise √† jour de la barre de progression
                const totalEpisodes = this.getTrainingConfig().episodes;
                const progress = ((metrics.episode || 0) / totalEpisodes) * 100;
                document.getElementById('trainingProgress').style.width = `${Math.min(progress, 100)}%`;
                document.getElementById('progressText').textContent = 
                    `√âpisode ${metrics.episode || 0} / ${totalEpisodes}`;
                
                // Mise √† jour des m√©triques de concurrence TensorFlow.js
                if (this.trainingOrchestrator && this.trainingOrchestrator.rocketAI && 
                    typeof this.trainingOrchestrator.rocketAI.getConcurrencyMetrics === 'function') {
                    const concurrencyMetrics = this.trainingOrchestrator.rocketAI.getConcurrencyMetrics();
                    document.getElementById('totalTrainingCalls').textContent = concurrencyMetrics.totalTrainingCalls || 0;
                    document.getElementById('blockedCalls').textContent = concurrencyMetrics.blockedCalls || 0;
                    document.getElementById('successfulTrainings').textContent = concurrencyMetrics.successfulTrainings || 0;
                    document.getElementById('blockingRate').textContent = concurrencyMetrics.blockingRate || '0.0%';
                    document.getElementById('averageTrainingDuration').textContent = Math.round(concurrencyMetrics.averageTrainingDuration || 0);
                    document.getElementById('lastTrainingTime').textContent = concurrencyMetrics.lastTrainingTime || 0;
                }
                
                // Mise √† jour des statistiques d'entra√Ænement
                this.updateTrainingStatistics(metrics);
            }

            updateCharts(episode, reward, loss) {
                // Limiter √† 100 points pour les performances
                if (this.trainingData.rewards.length > 100) {
                    this.trainingData.rewards.shift();
                    this.trainingData.losses.shift();
                    this.trainingData.episodes.shift();
                }
                
                this.trainingData.episodes.push(episode);
                this.trainingData.rewards.push(reward);
                this.trainingData.losses.push(loss);
                
                this.rewardChart.data.labels = this.trainingData.episodes;
                this.rewardChart.data.datasets[0].data = this.trainingData.rewards;
                this.rewardChart.update('none');
                
                this.lossChart.data.labels = this.trainingData.episodes;
                this.lossChart.data.datasets[0].data = this.trainingData.losses;
                this.lossChart.update('none');
            }
            
            updateTrainingStatistics(metrics) {
                // Calculer le temps total d'entra√Ænement
                if (this.trainingOrchestrator && this.trainingOrchestrator.metrics && this.trainingOrchestrator.metrics.trainingStartTime) {
                    const totalTime = Date.now() - this.trainingOrchestrator.metrics.trainingStartTime;
                    const totalSeconds = Math.floor(totalTime / 1000);
                    const hours = Math.floor(totalSeconds / 3600);
                    const minutes = Math.floor((totalSeconds % 3600) / 60);
                    const seconds = totalSeconds % 60;
                    
                    let timeStr = '';
                    if (hours > 0) timeStr += `${hours}h `;
                    if (minutes > 0) timeStr += `${minutes}m `;
                    timeStr += `${seconds}s`;
                    
                    document.getElementById('totalTrainingTime').textContent = timeStr;
                    
                    // Temps moyen par √©pisode
                    if (metrics.episode > 0) {
                        const avgTimePerEpisode = totalTime / metrics.episode;
                        const avgSeconds = Math.floor(avgTimePerEpisode / 1000);
                        document.getElementById('averageEpisodeTime').textContent = `${avgSeconds}s`;
                    }
                } else {
                    document.getElementById('totalTrainingTime').textContent = '0s';
                    document.getElementById('averageEpisodeTime').textContent = '0s';
                }
                
                // Meilleure r√©compense
                if (metrics.averageRewards && metrics.averageRewards.length > 0) {
                    const bestReward = Math.max(...metrics.averageRewards);
                    document.getElementById('bestReward').textContent = bestReward.toFixed(2);
                } else {
                    document.getElementById('bestReward').textContent = '0.00';
                }
                
                // Taille du mod√®le (estimation)
                if (this.trainingOrchestrator && this.trainingOrchestrator.rocketAI && this.trainingOrchestrator.rocketAI.model) {
                    try {
                        const modelSize = this.trainingOrchestrator.rocketAI.model.countParams() * 4; // 4 bytes par param√®tre (float32)
                        const sizeKB = Math.round(modelSize / 1024);
                        document.getElementById('modelSize').textContent = `${sizeKB} KB`;
                    } catch (e) {
                        document.getElementById('modelSize').textContent = 'N/A';
                    }
                } else {
                    document.getElementById('modelSize').textContent = '0 KB';
                }
                
                // Utilisation m√©moire (estimation)
                if (typeof performance !== 'undefined' && performance.memory) {
                    const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                    document.getElementById('memoryUsage').textContent = `${memoryMB} MB`;
                } else {
                    document.getElementById('memoryUsage').textContent = 'N/A';
                }
                
                // Efficacit√© d'entra√Ænement (taux de succ√®s * vitesse)
                const successRate = metrics.successRate || 0;
                const efficiency = Math.round(successRate);
                document.getElementById('trainingEfficiency').textContent = `${efficiency}%`;
            }

            log(message, type = 'info') {
                const logContainer = document.getElementById('logContainer');
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.textContent = `[${timestamp}] ${message}`;
                
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // Limiter √† 200 entr√©es
                while (logContainer.children.length > 200) {
                    logContainer.removeChild(logContainer.firstChild);
                }
                
                // Aussi logger dans la console
                console.log(`[${type.toUpperCase()}] ${message}`);
            }

            async saveModel() {
                this.log('Sauvegarde du mod√®le en cours...', 'info');
                try {
                    // Cr√©er un agent temporaire si n√©cessaire
                    let rocketAI = this.trainingOrchestrator.rocketAI;
                    if (!rocketAI) {
                        this.log('Cr√©ation d\'un agent IA temporaire pour la sauvegarde...', 'info');
                        rocketAI = new RocketAI(this.eventBus);
                    }
                    
                    await rocketAI.saveModel();
                    this.log('Mod√®le sauvegard√© avec succ√®s', 'success');
                } catch (error) {
                    this.log(`Erreur lors de la sauvegarde: ${error.message}`, 'error');
                }
            }

            async loadModel() {
                this.log('Chargement du mod√®le en cours...', 'info');
                try {
                    // Cr√©er un agent temporaire si n√©cessaire
                    let rocketAI = this.trainingOrchestrator.rocketAI;
                    if (!rocketAI) {
                        this.log('Cr√©ation d\'un agent IA temporaire pour le chargement...', 'info');
                        rocketAI = new RocketAI(this.eventBus);
                    }
                    
                    const success = await rocketAI.loadModel();
                    if (success) {
                        this.log('Mod√®le charg√© avec succ√®s', 'success');
                    } else {
                        this.log('Aucun mod√®le sauvegard√© trouv√©', 'info');
                    }
                } catch (error) {
                    this.log(`Erreur lors du chargement: ${error.message}`, 'error');
                }
            }

            resetTraining() {
                this.stopTraining();
                
                // Attendre un peu que l'arr√™t soit effectif
                setTimeout(() => {
                    this.currentEpisode = 0;
                    this.totalSteps = 0;
                    this.trainingData = { rewards: [], losses: [], episodes: [] };
                    
                    this.updateMetrics({});
                    this.rewardChart.data.labels = [];
                    this.rewardChart.data.datasets[0].data = [];
                    this.rewardChart.update();
                    this.lossChart.data.labels = [];
                    this.lossChart.data.datasets[0].data = [];
                    this.lossChart.update();
                    
                    this.log('Entra√Ænement r√©initialis√©', 'info');
                }, 1000);
            }
            
            // M√©thodes de visualisation
            initializeVisualizer() {
                const canvas = document.getElementById('visualizationCanvas');
                if (!canvas) {
                    console.warn('Canvas de visualisation non trouv√©');
                    return;
                }
                
                this.visualizer = new TrainingVisualizer(canvas, this.eventBus);
                this.visualizationActive = false;
                
                // Redimensionner le canvas
                this.resizeVisualizationCanvas();
                
                // √âcouter les redimensionnements
                window.addEventListener('resize', () => this.resizeVisualizationCanvas());
                
                this.log('Visualiseur d\'entra√Ænement initialis√©', 'success');
            }
            
            resizeVisualizationCanvas() {
                const canvas = document.getElementById('visualizationCanvas');
                const panel = document.getElementById('visualizationPanel');
                if (!canvas || !panel) return;
                
                // Obtenir les dimensions du conteneur parent du canvas
                const container = canvas.parentElement;
                if (!container) return;
                
                const rect = container.getBoundingClientRect();
                
                // Calculer les dimensions pour utiliser toute la largeur disponible
                const maxWidth = Math.floor(rect.width - 40); // Marge de 20px de chaque c√¥t√©
                const maxHeight = Math.floor(rect.height - 20); // Marge de 10px de chaque c√¥t√©
                
                // Utiliser toute la largeur disponible avec une hauteur proportionnelle
                const width = Math.max(400, Math.min(maxWidth, 1200)); // Entre 400 et 1200px
                const height = Math.max(400, Math.min(maxHeight, 600)); // Entre 400 et 600px
                
                // Appliquer les dimensions
                canvas.width = width;
                canvas.height = height;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                
                if (this.visualizer) {
                    this.visualizer.resize(width, height);
                }
                
                console.log(`Canvas redimensionn√©: ${width}x${height}`);
            }
            
            onTrainingModeChanged(mode) {
                const panel = document.getElementById('visualizationPanel');
                if (mode === 'visual') {
                    panel.style.display = 'block';
                    this.resizeVisualizationCanvas();
                    this.log('Mode de visualisation activ√©', 'info');
                } else {
                    panel.style.display = 'none';
                    if (this.visualizationActive) {
                        this.toggleVisualization();
                    }
                    this.log('Mode headless activ√©', 'info');
                }
            }
            
            toggleVisualization() {
                if (!this.visualizer) {
                    this.log('Visualiseur non initialis√©', 'error');
                    return;
                }
                
                this.visualizationActive = !this.visualizationActive;
                this.visualizer.setActive(this.visualizationActive);
                
                const button = document.getElementById('toggleVisualization');
                if (this.visualizationActive) {
                    button.textContent = 'üëÅÔ∏è D√©sactiver';
                    this.log('Visualisation activ√©e', 'info');
                } else {
                    button.textContent = 'üëÅÔ∏è Activer';
                    this.log('Visualisation d√©sactiv√©e', 'info');
                }
            }
            
            clearTrajectory() {
                if (this.visualizer) {
                    this.visualizer.clearTrajectory();
                    this.log('Trajectoire effac√©e', 'info');
                }
            }
            
            zoomIn() {
                if (this.visualizer) {
                    const factor = this.visualizer.camera.targetZoom < 0.0001 ? 2.0 : 1.5;
                    const newZoom = Math.min(this.visualizer.camera.maxZoom, this.visualizer.camera.targetZoom * factor);
                    this.visualizer.camera.targetZoom = newZoom;
                    this.log(`Zoom avant: ${newZoom.toExponential(2)}`, 'info');
                }
            }
            
            zoomOut() {
                if (this.visualizer) {
                    const factor = this.visualizer.camera.targetZoom > 0.0001 ? 1.5 : 2.0;
                    const newZoom = Math.max(this.visualizer.camera.minZoom, this.visualizer.camera.targetZoom / factor);
                    this.visualizer.camera.targetZoom = newZoom;
                    this.log(`Zoom arri√®re: ${newZoom.toExponential(2)}`, 'info');
                }
            }
        }

        // Initialiser l'interface au chargement
        document.addEventListener('DOMContentLoaded', () => {
            try {
                // Initialiser ControllerContainer global pour les d√©pendances
                if (typeof ControllerContainer !== 'undefined') {
                    window.controllerContainer = new ControllerContainer();
                }
                
                window.trainingInterface = new TrainingInterface();
                
                // CORRECTION : Ajouter les fonctions de test directement √† window
                if (typeof window.testUpdateFrequency === 'undefined') {
                    console.log('üîß Ajout des fonctions de test directement...');
                    
                    // Test de fr√©quence d'updates
                    window.testUpdateFrequency = async function() {
                        console.log('‚ö° TEST DE FR√âQUENCE D\'UPDATES R√âELLE');
                        console.log('=====================================');
                        
                        try {
                            const eventBus = new EventBus();
                            const rocketAI = new RocketAI(eventBus);
                            
                            console.log(`Configuration: updateFrequency = ${rocketAI.config.updateFrequency} pas`);
                            
                            // Compter les updates pendant une simulation courte
                            const originalTrain = rocketAI.train.bind(rocketAI);
                            let updateCount = 0;
                            
                            rocketAI.train = async function() {
                                updateCount++;
                                console.log(`Update #${updateCount} √† l'√©tape ${this.totalSteps}`);
                                return originalTrain();
                            };
                            
                            // Remplir le buffer avec des donn√©es factices
                            console.log('Remplissage du buffer...');
                            for (let i = 0; i < rocketAI.config.batchSize + 10; i++) {
                                rocketAI.replayBuffer.push({
                                    state: Array(10).fill(Math.random() * 0.1),
                                    action: Math.floor(Math.random() * 5),
                                    reward: Math.random() * 2 - 1,
                                    nextState: Array(10).fill(Math.random() * 0.1),
                                    done: false
                                });
                            }
                            
                            console.log(`Buffer rempli: ${rocketAI.replayBuffer.length} exp√©riences`);
                            
                            // Simuler 100 pas
                            const targetSteps = 100;
                            console.log(`\nSimulation de ${targetSteps} pas...`);
                            
                            rocketAI.isTraining = true;
                            rocketAI.rocketData = {
                                x: 100000, y: 6471000, vx: 100, vy: 0,
                                angle: 0, angularVelocity: 0.01
                            };
                            rocketAI.celestialBodyData = {
                                x: 0, y: 6471000, radius: 6371000
                            };
                            
                            for (let step = 0; step < targetSteps; step++) {
                                rocketAI.totalSteps = step;
                                
                                // Simuler step() sans vraiment appeler l'entra√Ænement complet
                                if (step % rocketAI.config.updateFrequency === 0 && rocketAI.replayBuffer.length >= rocketAI.config.batchSize) {
                                    await rocketAI.train();
                                }
                            }
                            
                            const expectedUpdates = Math.floor(targetSteps / rocketAI.config.updateFrequency);
                            
                            console.log(`\nüìä R√âSULTATS:`);
                            console.log(`   Steps simul√©s: ${targetSteps}`);
                            console.log(`   Updates attendus: ${expectedUpdates}`);
                            console.log(`   Updates r√©els: ${updateCount}`);
                            console.log(`   Ratio: ${updateCount}/${targetSteps} = ${(updateCount/targetSteps*100).toFixed(1)}%`);
                            
                            if (updateCount === expectedUpdates) {
                                console.log(`   ‚úÖ PARFAIT! Fr√©quence respect√©e.`);
                            } else if (updateCount > expectedUpdates * 0.8) {
                                console.log(`   ‚ö° CORRECT, l√©g√®re variation acceptable.`);
                            } else {
                                console.log(`   ‚ùå PROBL√àME: Trop peu d'updates r√©els.`);
                            }
                            
                            // Restaurer la fonction originale
                            rocketAI.train = originalTrain;
                            
                        } catch (error) {
                            console.error('‚ùå Erreur lors du test de fr√©quence:', error);
                        }
                    };
                    
                    // Diagnostic complet
                    window.diagnosticComplet = async function() {
                        console.log('üîç DIAGNOSTIC COMPLET DU SYST√àME D\'APPRENTISSAGE');
                        console.log('===================================================');
                        
                        try {
                            const eventBus = new EventBus();
                            const rocketAI = new RocketAI(eventBus);
                            
                            // Test 1: Configuration epsilon
                            console.log('\n1Ô∏è‚É£ TEST DE LA D√âCROISSANCE D\'EPSILON:');
                            console.log(`   Epsilon initial: ${rocketAI.config.epsilon}`);
                            console.log(`   Epsilon decay: ${rocketAI.config.epsilonDecay}`);
                            console.log(`   Epsilon min: ${rocketAI.config.epsilonMin}`);
                            
                            // Simulation de la d√©croissance
                            let testEpsilon = rocketAI.config.epsilon;
                            let episodes = 0;
                            while (testEpsilon > 0.1 && episodes < 500) {
                                testEpsilon *= rocketAI.config.epsilonDecay;
                                episodes++;
                            }
                            console.log(`   üéØ √âpisodes pour atteindre Œµ=0.1: ${episodes}`);
                            if (episodes > 150) {
                                console.log(`   ‚ö†Ô∏è TROP LENT! Devrait √™tre ~100 √©pisodes max`);
                            } else {
                                console.log(`   ‚úÖ D√©croissance correcte`);
                            }
                            
                            // Test 2: Configuration fr√©quence
                            console.log('\n2Ô∏è‚É£ TEST DE LA FR√âQUENCE D\'ENTRA√éNEMENT:');
                            console.log(`   Update frequency (RocketAI): ${rocketAI.config.updateFrequency} pas`);
                            console.log(`   üéØ ATTENDU: 1000 pas ‚Üí ${Math.floor(1000 / rocketAI.config.updateFrequency)} entra√Ænements`);
                            console.log(`   Batch size: ${rocketAI.config.batchSize}`);
                            console.log(`   Replay buffer size: ${rocketAI.config.replayBufferSize}`);
                            
                            const stepsFor100Updates = rocketAI.config.updateFrequency * 100;
                            console.log(`   ‚ö° 100 entra√Ænements en ${stepsFor100Updates} pas (${(stepsFor100Updates/60).toFixed(1)}s √† 60fps)`);
                            
                            if (rocketAI.config.updateFrequency <= 8) {
                                console.log(`   ‚úÖ Fr√©quence excellente pour apprentissage rapide`);
                            } else if (rocketAI.config.updateFrequency <= 32) {
                                console.log(`   ‚ö° Fr√©quence correcte`);
                            } else {
                                console.log(`   ‚ö†Ô∏è Fr√©quence trop faible, apprentissage lent`);
                            }
                            
                            console.log('\n‚úÖ Diagnostic termin√©. Utilisez testUpdateFrequency() pour un test complet.');
                            
                        } catch (error) {
                            console.error('‚ùå Erreur lors du diagnostic:', error);
                        }
                    };
                    
                    // Test d'√©valuation
                    window.testEvaluationMode = async function() {
                        console.log('üß™ Test d\'√©valuation (Œµ=0) - Fonctionnalit√© disponible');
                        console.log('Note: Cette fonction n√©cessite train.js pour fonctionner compl√®tement.');
                        
                        // Version simplifi√©e pour l'interface
                        try {
                            const eventBus = new EventBus();
                            const rocketAI = new RocketAI(eventBus);
                            
                            const originalEpsilon = rocketAI.config.epsilon;
                            rocketAI.config.epsilon = 0.0;
                            
                            console.log(`‚úÖ Epsilon forc√© √† 0 (√©tait ${originalEpsilon.toFixed(3)})`);
                            console.log('Pour un test complet, utilisez la version dans train.js');
                            
                            rocketAI.config.epsilon = originalEpsilon;
                            
                        } catch (error) {
                            console.error('‚ùå Erreur:', error);
                        }
                    };
                    
                    console.log('\nüéÆ Fonctions de test ajout√©es:');
                    console.log('   testUpdateFrequency() - Test du nombre d\'updates r√©els');
                    console.log('   diagnosticComplet() - Diagnostic complet du syst√®me');
                    console.log('   testEvaluationMode() - Test d\'√©valuation simplifi√©');
                    
                    // Test rapide pour valider toutes les corrections
                    window.testCorrections = function() {
                        console.log('üöÄ VALIDATION RAPIDE DES CORRECTIONS');
                        console.log('=====================================');
                        
                        try {
                            const eventBus = new EventBus();
                            const rocketAI = new RocketAI(eventBus);
                            
                            console.log('‚úÖ RocketAI cr√©√© avec succ√®s');
                            console.log(`üìä Configuration actuelle:`);
                            console.log(`   - updateFrequency: ${rocketAI.config.updateFrequency} pas (CORRIG√â de 1000‚Üí4)`);
                            console.log(`   - epsilonDecay: ${rocketAI.config.epsilonDecay} (CORRIG√â de 0.995‚Üí0.98)`);
                            console.log(`   - batchSize: ${rocketAI.config.batchSize}`);
                            console.log(`   - replayBufferSize: ${rocketAI.config.replayBufferSize}`);
                            
                            // Calculs d'efficacit√©
                            const updates1000steps = Math.floor(1000 / rocketAI.config.updateFrequency);
                            const epsilonAt100eps = Math.pow(rocketAI.config.epsilonDecay, 100);
                            
                            console.log(`\nüéØ Impact des corrections:`);
                            console.log(`   - Updates en 1000 pas: ${updates1000steps} (√©tait ~1 avant)`);
                            console.log(`   - Gain d'entra√Ænement: √ó${updates1000steps} plus d'apprentissage!`);
                            console.log(`   - Epsilon apr√®s 100 √©pisodes: ${epsilonAt100eps.toFixed(3)} (√©tait ~0.6 avant)`);
                            
                            if (updates1000steps > 200) {
                                console.log(`   ‚úÖ EXCELLENT: Fr√©quence d'entra√Ænement tr√®s √©lev√©e`);
                            } else if (updates1000steps > 50) {
                                console.log(`   ‚ö° BIEN: Fr√©quence d'entra√Ænement correcte`);
                            } else {
                                console.log(`   ‚ö†Ô∏è ATTENTION: Fr√©quence encore un peu faible`);
                            }
                            
                            if (epsilonAt100eps < 0.2) {
                                console.log(`   ‚úÖ EXCELLENT: D√©croissance epsilon rapide`);
                            } else {
                                console.log(`   ‚ö†Ô∏è ATTENTION: D√©croissance epsilon encore lente`);
                            }
                            
                            console.log(`\nüìà Pr√©dictions de performance:`);
                            console.log(`   - L'agent devrait apprendre ${updates1000steps}√ó plus vite`);
                            console.log(`   - Loss devrait √™tre > 0 d√®s les premiers entra√Ænements`);
                            console.log(`   - R√©compenses positives attendues avec le nouveau shaping`);
                            console.log(`   - Normalisation s√©curis√©e = plus de NaN dans les gradients`);
                            
                            console.log(`\nüß™ Prochaine √©tape: testUpdateFrequency() pour validation compl√®te`);
                            
                        } catch (error) {
                            console.error('‚ùå Erreur lors de la validation:', error);
                        }
                    };
                    
                    console.log('   testCorrections() - üöÄ Validation rapide de TOUTES les corrections');
                }
                
            } catch (error) {
                console.error('Erreur lors de l\'initialisation de l\'interface:', error);
                document.body.innerHTML = `
                    <div style="color: red; padding: 20px; font-family: Arial;">
                        <h1>Erreur d'Initialisation</h1>
                        <p><strong>Erreur:</strong> ${error.message}</p>
                        <p>V√©rifiez que tous les fichiers sont correctement charg√©s et que le serveur est lanc√©.</p>
                        <p>Consultez la console pour plus de d√©tails.</p>
                    </div>
                `;
            }
        });
    </script>
</body>
</html> 