<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entra√Ænement IA - Rocket Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
            color: white;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-weight: bold;
            color: #8cf;
        }
        input, select, button {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #333;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        button {
            background: linear-gradient(45deg, #4a90e2, #7b68ee);
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background: linear-gradient(45deg, #5ba0f2, #8b78fe);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        .metric {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #8cf;
        }
        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2, #7b68ee);
            width: 0%;
            transition: width 0.3s ease;
        }
        .log-container {
            height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
        }
        .log-entry {
            margin: 2px 0;
            opacity: 0.8;
        }
        .log-error { color: #ff6b6b; }
        .log-success { color: #51cf66; }
        .log-info { color: #74c0fc; }
        .charts {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        .chart-container {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            height: 200px;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-idle { background: #ffd43b; }
        .status-training { background: #51cf66; animation: pulse 1s infinite; }
        .status-error { background: #ff6b6b; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.13.0/dist/tf.min.js"></script>
    <!-- Chart.js pour les graphiques -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Biblioth√®ques physiques -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- Plugin Matter Attractors -->
    <script src="https://cdn.jsdelivr.net/npm/matter-attractors@0.1.6/build/matter-attractors.min.js"></script>
    
    <!-- D√©pendances n√©cessaires pour l'entra√Ænement -->
    <script src="constants.js"></script>
    <script src="controllers/EventBus.js"></script>
    <script src="EventTypes.js"></script>
    <script src="models/UniverseModel.js"></script>
    <script src="models/CelestialBodyModel.js"></script>
    <script src="models/RocketModel.js"></script>
    <script src="models/CameraModel.js"></script>
    <script src="models/ParticleModel.js"></script>
    <script src="models/ParticleSystemModel.js"></script>
    
    <!-- Contr√¥leurs n√©cessaires pour HeadlessRocketEnvironment -->
    <script src="controllers/BodyFactory.js"></script>
    <script src="controllers/CollisionHandler.js"></script>
    <script src="controllers/ThrusterPhysics.js"></script>
    <script src="controllers/SynchronizationManager.js"></script>
    <script src="controllers/PhysicsVectors.js"></script>
    <script src="controllers/PhysicsController.js"></script>
    <script src="controllers/ParticleController.js"></script>
    <script src="controllers/RocketController.js"></script>
    <script src="controllers/MissionManager.js"></script>
    <script src="controllers/RocketCargo.js"></script>
    <script src="controllers/CelestialBodyFactory.js"></script>
    <script src="controllers/ControllerContainer.js"></script>
    
    <!-- Composants IA -->
    <script src="controllers/RocketAI.js"></script>
    <script src="controllers/HeadlessRocketEnvironment.js"></script>
    <script src="controllers/TrainingOrchestrator.js"></script>
</head>
<body>
    <div class="container">
        <div class="panel">
            <h2>üöÄ Configuration d'Entra√Ænement</h2>
            <div class="controls">
                <div class="control-group">
                    <label>√âpisodes d'entra√Ænement:</label>
                    <input type="number" id="episodes" value="1000" min="10" max="10000">
                </div>
                <div class="control-group">
                    <label>Taux d'apprentissage:</label>
                    <input type="number" id="learningRate" value="0.001" step="0.0001" min="0.0001" max="0.1">
                </div>
                <div class="control-group">
                    <label>Epsilon initial:</label>
                    <input type="number" id="epsilon" value="1.0" step="0.1" min="0.1" max="1.0">
                </div>
                <div class="control-group">
                    <label>Gamma (discount factor):</label>
                    <input type="number" id="gamma" value="0.99" step="0.01" min="0.8" max="0.99">
                </div>
                <div class="control-group">
                    <label>Taille du batch:</label>
                    <input type="number" id="batchSize" value="32" min="8" max="128">
                </div>
                <div class="control-group">
                    <label>Fr√©quence de mise √† jour:</label>
                    <input type="number" id="updateFreq" value="1000" min="100" max="5000">
                </div>
                <div class="control-group">
                    <label>Objectif d'entra√Ænement:</label>
                    <select id="objective">
                        <option value="orbit">Maintenir orbite</option>
                        <option value="land">Atterrissage pr√©cis</option>
                        <option value="explore">Exploration libre</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Mode d'entra√Ænement:</label>
                    <select id="trainingMode">
                        <option value="headless">Sans rendu (rapide)</option>
                        <option value="visual">Avec visualisation</option>
                        <option value="hybrid">Hybride</option>
                    </select>
                </div>
            </div>
            
            <div class="controls">
                <button id="startTraining">üéØ D√©marrer l'Entra√Ænement</button>
                <button id="pauseTraining" disabled>‚è∏Ô∏è Pause</button>
                <button id="stopTraining" disabled>‚èπÔ∏è Arr√™ter</button>
                <button id="saveModel">üíæ Sauvegarder Mod√®le</button>
                <button id="loadModel">üìÇ Charger Mod√®le</button>
                <button id="resetTraining">üîÑ Reset</button>
            </div>
        </div>

        <div class="panel">
            <h2>üìä M√©triques en Temps R√©el</h2>
            <div class="metrics-grid">
                <div class="metric">
                    <div class="metric-value" id="currentEpisode">0</div>
                    <div class="metric-label">√âpisode Actuel</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="totalSteps">0</div>
                    <div class="metric-label">√âtapes Totales</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="avgReward">0.00</div>
                    <div class="metric-label">R√©compense Moy.</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="successRate">0%</div>
                    <div class="metric-label">Taux de Succ√®s</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="currentEpsilon">1.00</div>
                    <div class="metric-label">Exploration (Œµ)</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="loss">0.00</div>
                    <div class="metric-label">Perte d'Entra√Ænement</div>
                </div>
            </div>
            
            <div>
                <h3>Progression:</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="trainingProgress"></div>
                </div>
                <div id="progressText">Pr√™t pour l'entra√Ænement</div>
            </div>
        </div>

        <div class="panel">
            <h2>üìà Graphiques de Performance</h2>
            <div class="charts">
                <div class="chart-container">
                    <canvas id="rewardChart"></canvas>
                </div>
                <div class="chart-container">
                    <canvas id="lossChart"></canvas>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>üìù Journal d'Entra√Ænement</h2>
            <div>
                <span class="status-indicator" id="statusIndicator"></span>
                <span id="statusText">Inactif</span>
            </div>
            <div class="log-container" id="logContainer">
                <div class="log-entry log-info">Interface d'entra√Ænement initialis√©e.</div>
                <div class="log-entry log-info">TensorFlow.js charg√© avec succ√®s.</div>
                <div class="log-entry log-info">Pr√™t pour l'entra√Ænement...</div>
            </div>
        </div>
    </div>

    <!-- Initialisation du plugin Matter Attractors -->
    <script>
        // Gestionnaire d'erreurs global pour capturer les probl√®mes
        window.addEventListener('error', (event) => {
            console.error('Erreur JS d√©tect√©e:', event.error);
            const errorMsg = `ERREUR: ${event.error?.message || event.message}\nFichier: ${event.filename}\nLigne: ${event.lineno}`;
            if (window.trainingInterface) {
                window.trainingInterface.log(errorMsg, 'error');
            }
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Promesse rejet√©e:', event.reason);
            if (window.trainingInterface) {
                window.trainingInterface.log(`Promesse rejet√©e: ${event.reason}`, 'error');
            }
        });

        try {
            Matter.use(MatterAttractors);
            console.log('Plugin Matter Attractors initialis√© avec succ√®s');
        } catch (e) {
            console.error("Erreur lors de l'initialisation du plugin Matter Attractors:", e);
        }
    </script>

    <script>
        // Configuration globale de l'interface d'entra√Ænement
        class TrainingInterface {
            constructor() {
                this.isTraining = false;
                this.isPaused = false;
                this.currentEpisode = 0;
                this.totalSteps = 0;
                this.trainingData = {
                    rewards: [],
                    losses: [],
                    episodes: []
                };
                
                this.log('Initialisation de l\'interface d\'entra√Ænement...', 'info');
                
                try {
                    // V√©rifier les d√©pendances critiques
                    this.checkDependencies();
                    
                    // Initialiser les composants r√©els d'entra√Ænement
                    this.eventBus = new EventBus();
                    this.trainingOrchestrator = new TrainingOrchestrator(this.eventBus);
                    
                    this.initializeCharts();
                    this.setupEventListeners();
                    this.setupTrainingEventListeners();
                    this.updateStatus('idle', 'Pr√™t pour l\'entra√Ænement');
                    
                    this.log('Interface d\'entra√Ænement initialis√©e avec succ√®s', 'success');
                } catch (error) {
                    this.log(`Erreur lors de l'initialisation: ${error.message}`, 'error');
                    this.updateStatus('error', 'Erreur d\'initialisation');
                }
            }

            checkDependencies() {
                const dependencies = [
                    { name: 'TensorFlow.js', check: () => typeof tf !== 'undefined' },
                    { name: 'Matter.js', check: () => typeof Matter !== 'undefined' },
                    { name: 'Matter Attractors', check: () => typeof MatterAttractors !== 'undefined' },
                    { name: 'EVENTS', check: () => typeof window.EVENTS !== 'undefined' },
                    { name: 'ROCKET constants', check: () => typeof ROCKET !== 'undefined' && ROCKET.FUEL_MAX !== 'undefined' },
                    { name: 'PHYSICS constants', check: () => typeof PHYSICS !== 'undefined' },
                    { name: 'EventBus', check: () => typeof EventBus !== 'undefined' },
                    { name: 'TrainingOrchestrator', check: () => typeof TrainingOrchestrator !== 'undefined' },
                    { name: 'HeadlessRocketEnvironment', check: () => typeof HeadlessRocketEnvironment !== 'undefined' },
                    { name: 'RocketAI', check: () => typeof RocketAI !== 'undefined' }
                ];

                const missing = dependencies.filter(dep => !dep.check());
                if (missing.length > 0) {
                    const missingNames = missing.map(dep => dep.name).join(', ');
                    throw new Error(`D√©pendances manquantes: ${missingNames}`);
                }
                
                this.log('Toutes les d√©pendances sont pr√©sentes', 'success');
            }

            initializeCharts() {
                // Graphique des r√©compenses
                const rewardCtx = document.getElementById('rewardChart').getContext('2d');
                this.rewardChart = new Chart(rewardCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'R√©compense Moyenne',
                            data: [],
                            borderColor: '#4a90e2',
                            backgroundColor: 'rgba(74, 144, 226, 0.1)',
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            x: { display: false },
                            y: { 
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: { color: 'white' }
                            }
                        }
                    }
                });

                // Graphique des pertes
                const lossCtx = document.getElementById('lossChart').getContext('2d');
                this.lossChart = new Chart(lossCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Perte d\'Entra√Ænement',
                            data: [],
                            borderColor: '#7b68ee',
                            backgroundColor: 'rgba(123, 104, 238, 0.1)',
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            x: { display: false },
                            y: { 
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: { color: 'white' }
                            }
                        }
                    }
                });
            }

            setupEventListeners() {
                document.getElementById('startTraining').addEventListener('click', () => this.startTraining());
                document.getElementById('pauseTraining').addEventListener('click', () => this.pauseTraining());
                document.getElementById('stopTraining').addEventListener('click', () => this.stopTraining());
                document.getElementById('saveModel').addEventListener('click', () => this.saveModel());
                document.getElementById('loadModel').addEventListener('click', () => this.loadModel());
                document.getElementById('resetTraining').addEventListener('click', () => this.resetTraining());
            }

            setupTrainingEventListeners() {
                // √âcouter les √©v√©nements d'entra√Ænement r√©els
                this.eventBus.subscribe(window.EVENTS.AI.TRAINING_STARTED, (data) => {
                    this.log('Entra√Ænement d√©marr√©!', 'success');
                    this.updateStatus('training', 'Entra√Ænement en cours...');
                    this.isTraining = true;
                    this.updateButtons();
                });
                
                this.eventBus.subscribe(window.EVENTS.AI.TRAINING_PROGRESS, (data) => {
                    if (!data || !data.metrics) return;
                    
                    const metrics = data.metrics;
                    
                    // Calculer les m√©triques pour l'affichage avec des valeurs par d√©faut s√ªres
                    const avgReward = (metrics.averageRewards && metrics.averageRewards.length > 0) ? 
                        metrics.averageRewards.reduce((a, b) => a + b, 0) / metrics.averageRewards.length : 0;
                    const successRate = (metrics.successfulEpisodes && metrics.episode > 0) ? 
                        (metrics.successfulEpisodes / metrics.episode) * 100 : 0;
                    const currentEpsilon = (metrics.explorationRates && metrics.explorationRates.length > 0) ? 
                        metrics.explorationRates[metrics.explorationRates.length - 1] : 1.0;
                    const currentLoss = (metrics.losses && metrics.losses.length > 0) ? 
                        metrics.losses[metrics.losses.length - 1] : 0;
                    
                    this.updateMetrics({
                        episode: metrics.episode || 0,
                        totalSteps: metrics.totalSteps || 0,
                        avgReward: avgReward,
                        successRate: successRate,
                        epsilon: currentEpsilon,
                        loss: currentLoss
                    });
                    
                    // Mettre √† jour les graphiques p√©riodiquement
                    if (metrics.episode && metrics.episode % 10 === 0) {
                        this.updateCharts(metrics.episode, avgReward, currentLoss);
                    }
                    
                    // Log p√©riodique
                    if (metrics.episode && metrics.episode % 50 === 0) {
                        this.log(`√âpisode ${metrics.episode}: R√©compense=${avgReward.toFixed(2)}, Succ√®s=${successRate.toFixed(1)}%`, 'info');
                    }
                });
                
                this.eventBus.subscribe(window.EVENTS.AI.EVALUATION_COMPLETED, (data) => {
                    if (data && data.averageScore !== undefined && data.successRate !== undefined) {
                        this.log(`√âvaluation: Score=${data.averageScore.toFixed(2)}, Succ√®s=${(data.successRate * 100).toFixed(1)}%`, 'success');
                    }
                });
                
                this.eventBus.subscribe(window.EVENTS.AI.TRAINING_COMPLETED, (stats) => {
                    this.isTraining = false;
                    this.updateStatus('idle', 'Entra√Ænement termin√©');
                    this.updateButtons();
                    if (stats) {
                        this.log(`Entra√Ænement termin√©! √âpisodes: ${stats.episodes || 'N/A'}, Succ√®s: ${((stats.finalSuccessRate || 0) * 100).toFixed(1)}%`, 'success');
                    } else {
                        this.log('Entra√Ænement termin√©!', 'success');
                    }
                });
                
                this.eventBus.subscribe(window.EVENTS.AI.TRAINING_ERROR, (data) => {
                    this.isTraining = false;
                    this.updateStatus('error', 'Erreur d\'entra√Ænement');
                    this.updateButtons();
                    this.log(`Erreur: ${data?.error || 'Erreur inconnue'}`, 'error');
                });
                
                this.eventBus.subscribe(window.EVENTS.AI.TRAINING_STOPPED, () => {
                    this.isTraining = false;
                    this.isPaused = false;
                    this.updateStatus('idle', 'Entra√Ænement arr√™t√©');
                    this.updateButtons();
                    this.log('Entra√Ænement arr√™t√©', 'info');
                });

                this.eventBus.subscribe(window.EVENTS.AI.TRAINING_PAUSED, () => {
                    this.isPaused = true;
                    this.updateStatus('idle', 'Entra√Ænement en pause');
                    this.updateButtons();
                    this.log('Entra√Ænement mis en pause', 'info');
                });

                this.eventBus.subscribe(window.EVENTS.AI.TRAINING_RESUMED, () => {
                    this.isPaused = false;
                    this.updateStatus('training', 'Entra√Ænement repris');
                    this.updateButtons();
                    this.log('Entra√Ænement repris', 'info');
                });
            }

            startTraining() {
                if (this.isTraining && !this.isPaused) {
                    this.log('Entra√Ænement d√©j√† en cours', 'warning');
                    return;
                }

                if (this.isPaused) {
                    this.trainingOrchestrator.resumeTraining();
                    return;
                }

                try {
                    const config = this.getTrainingConfig();
                    this.log('D√©marrage de l\'entra√Ænement avec les param√®tres:', 'info');
                    this.log(JSON.stringify(config, null, 2), 'info');
                    
                    // Adapter la configuration pour TrainingOrchestrator
                    const orchestratorConfig = {
                        maxEpisodes: config.episodes,
                        learningRate: config.learningRate,
                        epsilon: config.epsilon,
                        gamma: config.gamma,
                        batchSize: config.batchSize,
                        headlessMode: config.trainingMode === 'headless',
                        objectives: [config.objective]
                    };
                    
                    // D√©marrer l'entra√Ænement r√©el
                    this.trainingOrchestrator.startTraining(orchestratorConfig)
                        .catch(error => {
                            this.log(`Erreur lors du d√©marrage: ${error.message}`, 'error');
                            this.isTraining = false;
                            this.updateButtons();
                            this.updateStatus('error', 'Erreur de d√©marrage');
                        });
                        
                } catch (error) {
                    this.log(`Erreur de configuration: ${error.message}`, 'error');
                    this.updateStatus('error', 'Erreur de configuration');
                }
            }

            pauseTraining() {
                if (!this.isTraining) return;
                this.trainingOrchestrator.pauseTraining();
            }

            resumeTraining() {
                if (!this.isPaused) return;
                this.trainingOrchestrator.resumeTraining();
            }

            stopTraining() {
                if (!this.isTraining) return;
                this.trainingOrchestrator.stopTraining();
            }

            getTrainingConfig() {
                return {
                    episodes: parseInt(document.getElementById('episodes').value) || 1000,
                    learningRate: parseFloat(document.getElementById('learningRate').value) || 0.001,
                    epsilon: parseFloat(document.getElementById('epsilon').value) || 1.0,
                    gamma: parseFloat(document.getElementById('gamma').value) || 0.99,
                    batchSize: parseInt(document.getElementById('batchSize').value) || 32,
                    updateFreq: parseInt(document.getElementById('updateFreq').value) || 1000,
                    objective: document.getElementById('objective').value || 'orbit',
                    trainingMode: document.getElementById('trainingMode').value || 'headless'
                };
            }

            updateButtons() {
                const startBtn = document.getElementById('startTraining');
                const pauseBtn = document.getElementById('pauseTraining');
                const stopBtn = document.getElementById('stopTraining');
                
                if (this.isPaused) {
                    startBtn.textContent = '‚ñ∂Ô∏è Reprendre';
                    startBtn.disabled = false;
                    pauseBtn.disabled = true;
                    stopBtn.disabled = false;
                } else if (this.isTraining) {
                    startBtn.textContent = 'üéØ D√©marrer l\'Entra√Ænement';
                    startBtn.disabled = true;
                    pauseBtn.disabled = false;
                    stopBtn.disabled = false;
                } else {
                    startBtn.textContent = 'üéØ D√©marrer l\'Entra√Ænement';
                    startBtn.disabled = false;
                    pauseBtn.disabled = true;
                    stopBtn.disabled = true;
                }
            }

            updateStatus(status, text) {
                const indicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('statusText');
                
                indicator.className = `status-indicator status-${status}`;
                statusText.textContent = text;
            }

            updateMetrics(metrics) {
                document.getElementById('currentEpisode').textContent = metrics.episode || 0;
                document.getElementById('totalSteps').textContent = metrics.totalSteps || 0;
                document.getElementById('avgReward').textContent = (metrics.avgReward || 0).toFixed(2);
                document.getElementById('successRate').textContent = `${(metrics.successRate || 0).toFixed(1)}%`;
                document.getElementById('currentEpsilon').textContent = (metrics.epsilon || 0).toFixed(3);
                document.getElementById('loss').textContent = (metrics.loss || 0).toFixed(4);
                
                // Mise √† jour de la barre de progression
                const totalEpisodes = this.getTrainingConfig().episodes;
                const progress = ((metrics.episode || 0) / totalEpisodes) * 100;
                document.getElementById('trainingProgress').style.width = `${Math.min(progress, 100)}%`;
                document.getElementById('progressText').textContent = 
                    `√âpisode ${metrics.episode || 0} / ${totalEpisodes}`;
            }

            updateCharts(episode, reward, loss) {
                // Limiter √† 100 points pour les performances
                if (this.trainingData.rewards.length > 100) {
                    this.trainingData.rewards.shift();
                    this.trainingData.losses.shift();
                    this.trainingData.episodes.shift();
                }
                
                this.trainingData.episodes.push(episode);
                this.trainingData.rewards.push(reward);
                this.trainingData.losses.push(loss);
                
                this.rewardChart.data.labels = this.trainingData.episodes;
                this.rewardChart.data.datasets[0].data = this.trainingData.rewards;
                this.rewardChart.update('none');
                
                this.lossChart.data.labels = this.trainingData.episodes;
                this.lossChart.data.datasets[0].data = this.trainingData.losses;
                this.lossChart.update('none');
            }

            log(message, type = 'info') {
                const logContainer = document.getElementById('logContainer');
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.textContent = `[${timestamp}] ${message}`;
                
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // Limiter √† 200 entr√©es
                while (logContainer.children.length > 200) {
                    logContainer.removeChild(logContainer.firstChild);
                }
                
                // Aussi logger dans la console
                console.log(`[${type.toUpperCase()}] ${message}`);
            }

            async saveModel() {
                this.log('Sauvegarde du mod√®le en cours...', 'info');
                try {
                    if (this.trainingOrchestrator.rocketAI) {
                        await this.trainingOrchestrator.rocketAI.saveModel();
                        this.log('Mod√®le sauvegard√© avec succ√®s', 'success');
                    } else {
                        throw new Error('Agent IA non initialis√©');
                    }
                } catch (error) {
                    this.log(`Erreur lors de la sauvegarde: ${error.message}`, 'error');
                }
            }

            async loadModel() {
                this.log('Chargement du mod√®le en cours...', 'info');
                try {
                    if (this.trainingOrchestrator.rocketAI) {
                        await this.trainingOrchestrator.rocketAI.loadModel();
                        this.log('Mod√®le charg√© avec succ√®s', 'success');
                    } else {
                        throw new Error('Agent IA non initialis√©');
                    }
                } catch (error) {
                    this.log(`Erreur lors du chargement: ${error.message}`, 'error');
                }
            }

            resetTraining() {
                this.stopTraining();
                
                // Attendre un peu que l'arr√™t soit effectif
                setTimeout(() => {
                    this.currentEpisode = 0;
                    this.totalSteps = 0;
                    this.trainingData = { rewards: [], losses: [], episodes: [] };
                    
                    this.updateMetrics({});
                    this.rewardChart.data.labels = [];
                    this.rewardChart.data.datasets[0].data = [];
                    this.rewardChart.update();
                    this.lossChart.data.labels = [];
                    this.lossChart.data.datasets[0].data = [];
                    this.lossChart.update();
                    
                    this.log('Entra√Ænement r√©initialis√©', 'info');
                }, 1000);
            }
        }

        // Initialiser l'interface au chargement
        document.addEventListener('DOMContentLoaded', () => {
            try {
                // Initialiser ControllerContainer global pour les d√©pendances
                if (typeof ControllerContainer !== 'undefined') {
                    window.controllerContainer = new ControllerContainer();
                }
                
                window.trainingInterface = new TrainingInterface();
            } catch (error) {
                console.error('Erreur lors de l\'initialisation de l\'interface:', error);
                document.body.innerHTML = `
                    <div style="color: red; padding: 20px; font-family: Arial;">
                        <h1>Erreur d'Initialisation</h1>
                        <p><strong>Erreur:</strong> ${error.message}</p>
                        <p>V√©rifiez que tous les fichiers sont correctement charg√©s et que le serveur est lanc√©.</p>
                        <p>Consultez la console pour plus de d√©tails.</p>
                    </div>
                `;
            }
        });
    </script>
</body>
</html> 